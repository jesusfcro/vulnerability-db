/*
Copyright 2020 Adevinta
*/

package processor

import (
	"errors"
	"reflect"
	"testing"
	"time"

	report "github.com/adevinta/vulcan-report"
	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

const (
	// Mock for an SQS check mssg.
	mockCheckMssg = "{\n  \"Type\" : \"Notification\",\n  \"MessageId\" : \"cb25c8ff-c0fa-5262-b2e2-9d545759f19c\",\n  \"TopicArn\" : \"arn:aws:sns:eu-west-1:123456789012:VulcanCore\",\n  \"Subject\" : \"Check\",\n  \"Message\" : \"{\\\"id\\\":\\\"984e49ee-53b7-4b81-ad5c-d7a9e5394083\\\",\\\"agent_id\\\":\\\"8861ef14-2048-4c9a-bb3e-ae4a8bd1dc42\\\",\\\"checktype_id\\\":\\\"b5707bbd-78d0-494e-b1b6-45bfb2ef6b49\\\",\\\"status\\\":\\\"FAILED\\\",\\\"target\\\":\\\"localhost\\\",\\\"options\\\":\\\"{\\\\\\\"sleep_time\\\\\\\":90}\\\",\\\"webhook\\\":null,\\\"score\\\":0.0,\\\"progress\\\":1.0,\\\"raw\\\":\\\"https://vulcan-results.com/v1/logs/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.log\\\",\\\"report\\\":\\\"https://vulcan-results.com/v1/reports/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.json\\\",\\\"deleted_at\\\":null,\\\"created_at\\\":\\\"2019-07-19T10:03:09.205Z\\\",\\\"updated_at\\\":\\\"2019-07-19T10:03:15.069Z\\\",\\\"scan_id\\\":null,\\\"queue_name\\\":\\\"vulcanGenericQueue\\\",\\\"tag\\\":\\\"tag\\\",\\\"checktype_name\\\":\\\"vulcan-sleep-experimental\\\"}\",\n  \"Timestamp\" : \"2019-07-19T10:03:15.086Z\",\n  \"SignatureVersion\" : \"1\",\n  \"Signature\" : \"dGVzdAo\",\n  \"SigningCertURL\" : \"https://sns.eu-west-1.amazonaws.com/SimpleNotificationService-1234567890.pem\",\n  \"UnsubscribeURL\" : \"https://sns.eu-west-1.amazonaws.com/?Action=Unsubscribe&SubscriptionArn=arn:aws:sns:eu-west-1:123456789012:VulcanCore:00000000-0000-0000-0000-000000000000\",\n  \"MessageAttributes\" : {\n    \"checktype_name\" : {\"Type\":\"String\",\"Value\":\"vulcan-sleep-experimental\"},\n    \"status\" : {\"Type\":\"String\",\"Value\":\"FAILED\"}\n  }\n}"

	pqNotFoundErr = "sql: no rows in result set"
)

type mockNotifier struct {
	calls uint8
}

func (n *mockNotifier) Push(mssg interface{}) error {
	n.calls++
	return nil
}

type inMemMockNotifier struct {
	sent []FindingNotification
}

func (n *inMemMockNotifier) Push(mssg interface{}) error {
	notif, _ := mssg.(FindingNotification)
	n.sent = append(n.sent, notif)
	return nil
}

type mockStore struct {
	store.VulnStore

	wantFindFindingErr              bool                  // Specifies if FindFinding must return error.
	wantNewFinding                  bool                  // Specifies if FindFinding must return NotFoundErr.
	wantNewCreateIssueIfNotExistErr bool                  // Specifies if CreateIssueIfNotExists must return an error.
	returnFindingStatus             string                // Specifies FindFinding returned finding's status.
	returnCreateEventStatus         string                // Specifies the finding status after calling CreateFindingEvent.
	returnLastFindingEvent          *store.FindingEvent   // Specifies the finding event to return for GetLastFindingEvent.
	returnSourceIssues              []*store.Issue        // Specifies the list of issues returned for GetIssuesBySource.
	returnOpenSourceFindings        []store.SourceFinding // Specifies the list of Finding statuses returned by the returnFindingStatuses,
	createIssueIfNotExistCalls      uint8                 // RecalculateFindingStatusResult return status.
	getOpenIssuesForSource          func(id string) ([]string, error)
	findIssueByID                   func(id string) (*store.Issue, error)
}

func (s *mockStore) CreateIssueIfNotExists(i store.Issue) (*store.Issue, error) {
	if s.wantNewCreateIssueIfNotExistErr {
		return nil, errors.New("Unexpected error")
	}
	s.createIssueIfNotExistCalls++
	return &store.Issue{
		ID: "issueA",
	}, nil
}
func (s *mockStore) FindFinding(f store.Finding) (*store.Finding, error) {
	if s.wantFindFindingErr {
		return nil, errors.New("Err")
	}

	if s.wantNewFinding {
		return nil, errors.New(pqNotFoundErr)
	}

	return &store.Finding{
		ID:     "findingA",
		Status: s.returnFindingStatus,
	}, nil
}
func (s *mockStore) CreateFinding(eventTime time.Time, f store.Finding, sourceID string) (*store.Finding, error) {
	return nil, nil
}
func (s *mockStore) CreateFindingEvent(checkTime time.Time, findingID, sourceID string, score float64) (*store.Finding, error) {
	return &store.Finding{
		Status: s.returnCreateEventStatus,
	}, nil
}

func (s *mockStore) GetLastFindingEvent(findingID string) (*store.FindingEvent, error) {
	return s.returnLastFindingEvent, nil
}

func (s *mockStore) GetIssuesBySource(sourceID string) ([]*store.Issue, error) {
	return s.returnSourceIssues, nil
}

func (s *mockStore) GetOpenIssuesForSource(id string) ([]string, error) {
	return s.getOpenIssuesForSource(id)
}

func (s *mockStore) FindIssueByID(id string) (*store.Issue, error) {
	return s.findIssueByID(id)
}

func (s *mockStore) GetOpenSourceFindings(id string) ([]store.SourceFinding, error) {
	return s.returnOpenSourceFindings, nil
}

type mockResClient struct {
	results.Client
	retErr    error
	retReport report.Report
}

func (c mockResClient) Download(reportURL string) (report.Report, error) {
	return c.retReport, c.retErr
}

// processor test fields
type fields struct {
	notifier    notify.Notifier
	store       *mockStore
	resClient   mockResClient
	logger      *log.Logger
	maxEventAge int
}

func TestProcess(t *testing.T) {
	type input struct {
		vulns []report.Vulnerability
	}

	logger := log.New()

	tests := []struct {
		name                          string
		fields                        fields
		input                         input
		expectedCreateIssueIfNotExist uint8
		expectedErr                   bool
	}{
		{
			name: "Should return  err",
			fields: fields{
				notifier: &mockNotifier{},
				store: &mockStore{
					wantNewCreateIssueIfNotExistErr: true,
				},
				resClient: mockResClient{},
				logger:    logger,
			},
			input: input{
				vulns: []report.Vulnerability{
					report.Vulnerability{
						Summary: "Vulnerability 1",
					},
				}},
			expectedErr: true,
		},
		{
			name: "Should create the new issues",
			fields: fields{
				notifier:  &mockNotifier{},
				store:     &mockStore{},
				resClient: mockResClient{},
				logger:    logger,
			},
			expectedErr:                   false,
			expectedCreateIssueIfNotExist: 2,
			input: input{
				vulns: []report.Vulnerability{
					report.Vulnerability{
						Summary: "Vulnerability 1",
					},
					report.Vulnerability{
						Summary: "Vulnerability 2",
					},
				}},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tt.fields.notifier,
				store:         tt.fields.store,
				resultsClient: tt.fields.resClient,
				logger:        tt.fields.logger,
			}

			_, err := processor.processVulns(tt.input.vulns)
			if err != nil && !tt.expectedErr {
				t.Fatalf("No error expected, but got: %v", err)
			}

			if tt.expectedCreateIssueIfNotExist != tt.fields.store.createIssueIfNotExistCalls {
				t.Fatalf("Create issue calls got different than expected, got %d, expected %d", tt.fields.store.createIssueIfNotExistCalls, tt.expectedCreateIssueIfNotExist)
			}
		})
	}
}

func TestNotifyOpenFindings(t *testing.T) {
	logger := log.New()
	tests := []struct {
		name                  string
		fields                fields
		source                store.Source
		expectedNotifications []FindingNotification
		expectedError         string
	}{
		{
			name: "Notifies2Vulns",
			source: store.Source{
				SourceFamily: store.SourceFamily{
					Component: "c",
					Name:      "n",
					Target:    "t",
				},
				ID:       "i",
				Instance: "ins",
				Options:  "o",
			},
			fields: fields{
				notifier: &inMemMockNotifier{
					sent: make([]FindingNotification, 2),
				},
				store: &mockStore{
					getOpenIssuesForSource: func(id string) ([]string, error) {
						return []string{"id1", "id2"}, nil
					},

					findIssueByID: func(id string) (*store.Issue, error) {
						issues := map[string]store.Issue{
							"id1": store.Issue{
								ID:          "id1",
								Summary:     "Summary one",
								CWEID:       1,
								Description: "description",
							},
							"id2": store.Issue{
								ID:          "id2",
								Summary:     "Summary two",
								CWEID:       2,
								Description: "description 2",
							},
						}
						i, ok := issues[id]
						if !ok {
							// Todo export error not found constant in order
							// to not having to mock it like this.
							return nil, errors.New("sql: no rows in result set")
						}
						return &i, nil
					},
				},
				resClient: mockResClient{},
				logger:    logger,
			},
			expectedNotifications: []FindingNotification{
				FindingNotification{
					TargetID:         "t",
					IssueID:          "id1",
					ChecktypeID:      "ins",
					ChecktypeName:    "c",
					CheckTypeOptions: "o",
					Vulnerability: vulnerability{
						ID:          "id1",
						Summary:     "Summary one",
						Score:       6.0,
						CWEID:       1,
						Description: "description",
					},
				},
				FindingNotification{
					TargetID:         "t",
					IssueID:          "id1",
					ChecktypeID:      "ins",
					ChecktypeName:    "c",
					CheckTypeOptions: "o",
					Vulnerability: vulnerability{
						ID:          "id2",
						Summary:     "Summary two",
						Score:       7.0,
						CWEID:       2,
						Description: "description 2",
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tt.fields.notifier,
				store:         tt.fields.store,
				resultsClient: tt.fields.resClient,
				logger:        tt.fields.logger,
			}

			err := processor.notifyOpenFindings(tt.source)
			if errToStr(err) != tt.expectedError {
				t.Fatalf("expected error different from got err, got: %v, expected %s", err, tt.expectedError)
			}
			got := tt.fields.notifier.(*inMemMockNotifier).sent
			if reflect.DeepEqual(tt.expectedNotifications, got) {
				t.Errorf("got != want, got %+v, want %+v", got, tt.expectedNotifications)
			}
		})
	}
}

func TestParseCheckMssg(t *testing.T) {
	// given
	expectedCheckMssg := &CheckMessage{
		ID:            "984e49ee-53b7-4b81-ad5c-d7a9e5394083",
		AgentID:       "8861ef14-2048-4c9a-bb3e-ae4a8bd1dc42",
		ChecktypeID:   "b5707bbd-78d0-494e-b1b6-45bfb2ef6b49",
		ChecktypeName: "vulcan-sleep-experimental",
		Status:        "FAILED",
		Target:        "localhost",
		Options:       "{\"sleep_time\":90}",
		Webhook:       "",
		Score:         0.0,
		Progress:      1.0,
		Raw:           "https://vulcan-results.com/v1/logs/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.log",
		Report:        "https://vulcan-results.com/v1/reports/dt=2019-07-19/scan=12345678-1234-1234-1234-123456789012/00000000-0000-0000-0000-000000000000.json",
		DeletedAt:     "",
		CreatedAt:     "2019-07-19T10:03:09.205Z",
		UpdatedAt:     "2019-07-19T10:03:15.069Z",
		ScanID:        "",
		QueueName:     "vulcanGenericQueue",
		Tag:           "tag",
	}

	// when
	checkMssg, err := parseCheckMssg(mockCheckMssg)
	if err != nil {
		t.Fatalf("Error parsing check mssg: %v", err)
	}

	// then
	if !reflect.DeepEqual(checkMssg, expectedCheckMssg) {
		t.Errorf("Error, expected:\n%v\nGot:\n%v", expectedCheckMssg, checkMssg)
	}
}

func TestParseCheckReport(t *testing.T) {
	logger := log.New()
	nowTime := time.Now()
	pastTime := nowTime.AddDate(0, 0, -2)
	mockErr := errors.New("MockErr")

	testCases := []struct {
		name          string
		fields        fields
		reportURL     string
		expectedTime  time.Time
		expectedVulns []report.Vulnerability
		expectedErr   error
	}{
		{
			name: "Happy path",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   nil,
		},
		{
			name: "Should return invalid report due to invalid URL",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: results.ErrInvalidURL,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
		{
			name: "Should return invalid report due to invalid resp status",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: results.ErrInvalidRespStatus,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
		{
			name: "Should return error",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: nowTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: mockErr,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   mockErr,
		},
		{
			name: "Should return invalid report due to max age exceeded",
			fields: fields{
				resClient: mockResClient{
					retReport: report.Report{
						CheckData: report.CheckData{
							EndTime: pastTime,
						},
						ResultData: report.ResultData{
							Vulnerabilities: []report.Vulnerability{},
						},
					},
					retErr: nil,
				},
				logger:      logger,
				maxEventAge: 1,
			},
			reportURL:     "mockURL",
			expectedTime:  nowTime,
			expectedVulns: []report.Vulnerability{},
			expectedErr:   ErrInvalidReport,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			processor := &CheckProcessor{
				notifier:      tc.fields.notifier,
				store:         tc.fields.store,
				resultsClient: tc.fields.resClient,
				logger:        tc.fields.logger,
				maxEventAge:   tc.fields.maxEventAge,
			}

			checkTime, vulns, err := processor.parseCheckReport(tc.reportURL)
			if err != tc.expectedErr {
				t.Fatalf("Expected error to be %v, but got %v",
					tc.expectedErr, err)
			}
			if err == nil {
				// If parsing was correct, verify expected data.
				if checkTime != tc.expectedTime {
					t.Fatalf("Expected check time to be %s, but got %s",
						tc.expectedTime.String(), checkTime.String())
				}
				if !reflect.DeepEqual(vulns, tc.expectedVulns) {
					t.Fatalf("Expected vulns to be:\n%v\nBut got:\n%v",
						tc.expectedVulns, vulns)
				}
			}
		})
	}

}

func errToStr(err error) string {
	if err == nil {
		return ""
	}
	return err.Error()
}
