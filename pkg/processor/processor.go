/*
Copyright 2020 Adevinta
*/

package processor

import (
	"encoding/json"
	"errors"
	"strings"
	"time"

	report "github.com/adevinta/vulcan-report"

	"github.com/adevinta/vulnerability-db/pkg/notify"
	"github.com/adevinta/vulnerability-db/pkg/results"
	"github.com/adevinta/vulnerability-db/pkg/store"
	log "github.com/sirupsen/logrus"
)

const (
	vulcanSource   = "vulcan"
	statusFinished = "FINISHED"
)

var (
	// ErrInvalidMssgFormat indicates that the check message has an invalid format.
	ErrInvalidMssgFmt = errors.New("Invalid message format")

	// ErrInvalidReportRplcFmt indicates that the format of the configured replacing
	// URL for vulcan-results is invalid.
	ErrInvalidReportRplcFmt = errors.New("Invalid report replace string format")

	// ErrInvalidReport indicates that a report URL or data is invalid.
	ErrInvalidReport = errors.New("Invalid report data")
)

// Resources defines the shape of the resources of a vulnerability that will
// be stored in a vulndb finding.
type Resources []ResourceGroup

// ResourceGroup reprents a resource in a vulndb finding.
type ResourceGroup struct {
	Name       string              `json:"name"`
	Attributes []string            `json:"attributes"`
	Resources  []map[string]string `json:"resources"`
}

// VulnResourcesFromReportResources populates vulnd db resources from vulcan vulnerability resources.
func VulnResourcesFromReportResources(vulnresources []report.ResourcesGroup) Resources {
	var res Resources
	for _, vr := range vulnresources {
		res = append(res, ResourceGroup{
			Name:       vr.Name,
			Attributes: vr.Header,
			Resources:  vr.Rows,
		})
	}
	return res
}

// CheckProcessor is a QueueProcessor implementation
// for vulcan check messages.
type CheckProcessor struct {
	notifier           notify.Notifier
	store              store.VulnStore
	resultsClient      results.Client
	logger             *log.Logger
	maxEventAge        int
	reportURLReplace   string
	reportURLReplaceBy string
}

// NewCheckProcessor builds a new Check Processor
func NewCheckProcessor(notifier notify.Notifier, store store.VulnStore, resultsClient results.Client, reportURLReplaceConfig string, maxEventAge int, logger *log.Logger) (*CheckProcessor, error) {
	var reportURLReplace, reportURLReplaceBy string
	if reportURLReplaceConfig != "" {
		parts := strings.Split(reportURLReplaceConfig, "|")
		if len(parts) != 2 {
			return nil, ErrInvalidReportRplcFmt
		}
		reportURLReplace = parts[0]
		reportURLReplaceBy = parts[1]
		logger.Infof("report replace string %s with %s", reportURLReplace, reportURLReplaceBy)
	}
	return &CheckProcessor{
		notifier,
		store,
		resultsClient,
		logger,
		maxEventAge,
		reportURLReplace,
		reportURLReplaceBy,
	}, nil
}

// ProcessMessage processes a vulcan check message
func (p *CheckProcessor) ProcessMessage(m string) error {
	// The way events are processed assumes  it's acceptable that the data
	// regarding the status and stats of the findings related to the source in
	// the message can be inconsistent while the the message is being
	// processed.

	check, err := parseCheckMssg(m)
	if err != nil {
		return err
	}

	l := p.logger.WithFields(log.Fields{
		"check_id": check.ID,
		"target":   check.Target,
		"tag":      check.Tag,
	})

	if check.Status != statusFinished {
		l.Warnf("Ignoring check with status %s", check.Status)
		return nil
	}

	l.WithFields(log.Fields{"report_url": check.Report}).Debug("Parsing report")
	checkTime, vulns, err := p.parseCheckReport(check.Report)
	if err != nil {
		if err == ErrInvalidReport {
			// If report is invalid, return nil
			// so mssg is deleted from queue.
			l.WithFields(
				log.Fields{"report_url": check.Report},
			).Warn("Ignoring check due to invalid report")
			err = nil
		}
		return err
	}

	l.Debug("Processing target")
	target, err := p.processTarget(check.Target)
	if err != nil {
		return err
	}

	l.Debugf("Processing %d vulnerabilities", len(vulns))
	sourceFindings, err := p.processVulns(vulns, check.Target)
	if err != nil {
		return err
	}

	source := p.sourceFromCheck(*check, target.ID, checkTime)

	l.Debugf("Processing source with %d source findings: %#v", len(sourceFindings), source)
	source, err = p.store.ProcessSourceExecution(source, sourceFindings)
	if err != nil {
		l.Errorf("Error while processing source: %#v", err)
		if !store.IsDuplicateErr(err) {
			return err
		}
	}

	l.Debug("Sending open findings")
	err = p.notifyOpenFindings(source, check.Target, check.Tag)
	if err != nil {
		return err
	}

	l.Info("Successfully processed check")
	return nil
}

// processTarget creates a new target in the vulnerability db for the given identifier
// and returns the created target if it does not exist. If target already exists returns it.
func (p *CheckProcessor) processTarget(identifier string) (*store.Target, error) {
	target := store.Target{
		Identifier: identifier,
	}

	return p.store.CreateTarget(target)
}

func (p *CheckProcessor) sourceFromCheck(c CheckMessage, targetID string, t time.Time) store.Source {
	source := store.Source{
		Instance: c.ID,
		Options:  c.Options,
		SourceFamily: store.SourceFamily{
			Name:      vulcanSource,
			Component: c.ChecktypeName,
			Target:    targetID,
		},
		Time: t,
	}
	return source
}

// parseCheckReport downloads the report data and returns the check end time and list of issues reported by it.
func (p *CheckProcessor) parseCheckReport(reportURL string) (time.Time, []report.Vulnerability, error) {
	if p.reportURLReplace != "" {
		reportURL = strings.Replace(reportURL, p.reportURLReplace, p.reportURLReplaceBy, -1)
	}

	report, err := p.resultsClient.Download(reportURL)
	if err != nil {
		if err == results.ErrInvalidURL || err == results.ErrInvalidRespStatus {
			// If error is due to invalid report URL
			// or invalid HTTP status code, discard report.
			p.logger.Warnf("Discarding report %s due to err: %s", reportURL, err)
			err = ErrInvalidReport
		}
		return time.Now(), nil, err
	}

	age := int(time.Now().Sub(report.EndTime).Hours() / 24)
	if p.maxEventAge > 0 && age > p.maxEventAge {
		p.logger.Warnf("Discarding report %s due to max age exceeded", reportURL)
		return time.Now(), nil, ErrInvalidReport
	}

	return report.EndTime, report.Vulnerabilities, nil
}

// processVulns iterates for every vulnerability, for each one, it ensures a
// issue is created if it does not exists, ir returns a slice if SourceFindings
// with the corresponding issue id and the score set in the vulnerability.
func (p *CheckProcessor) processVulns(vulns []report.Vulnerability, targetIdentifier string) ([]store.SourceFinding, error) {
	var created = make([]store.SourceFinding, 0)
	for _, vuln := range vulns {
		// Create issue.
		i := store.Issue{
			Summary:         vuln.Summary,
			CWEID:           vuln.CWEID,
			Description:     vuln.Description,
			Recommendations: vuln.Recommendations,
			ReferenceLinks:  vuln.References,
		}

		issue, err := p.store.CreateIssueIfNotExists(i)
		if err != nil {
			return nil, err
		}

		err = p.store.UpdateIssueLabels(issue.ID, vuln.Labels)
		if err != nil {
			return nil, err
		}

		r := VulnResourcesFromReportResources(vuln.Resources)
		var resources *[]byte
		if len(r) > 0 {
			res, err := json.Marshal(r)
			if err != nil {
				return nil, err
			}
			resources = &res
		}

		// Use Target Identifier as fallback value for Affected Resource
		if vuln.AffectedResource == "" {
			vuln.AffectedResource = targetIdentifier
		}

		// Use FindingDefaultFingerprint as fallback value for Fingerprint
		if vuln.Fingerprint == "" {
			vuln.Fingerprint = store.FindingDefaultFingerprint
		}

		created = append(created, store.SourceFinding{
			IssueID:          issue.ID,
			Score:            vuln.Score,
			Details:          vuln.Details,
			ImpactDetails:    vuln.ImpactDetails,
			AffectedResource: vuln.AffectedResource,
			Fingerprint:      vuln.Fingerprint,
			Resources:        resources,
		})
	}
	return created, nil
}

func (p *CheckProcessor) notifyOpenFindings(source store.Source, target, tag string) error {
	// Notify the findings found by this source that are still open. Note that
	// we assume that a finding can be notified multiple times when, for
	// instance, if checks for the same target are processed not in the same
	// order that they were executed.
	sourceF, err := p.store.GetOpenSourceFindings(source.ID)
	if err != nil {
		return err
	}

	p.logger.WithFields(log.Fields{
		"check_id": source.Instance,
		"target":   target,
		"tag":      tag,
	}).Debugf("Sending %d finding events", len(sourceF))

	for _, sf := range sourceF {
		issue, err := p.store.FindIssueByID(sf.IssueID)
		if err != nil {
			return err
		}
		f, err := p.store.FindFinding(store.Finding{TargetID: source.Target, IssueID: issue.ID, AffectedResource: sf.AffectedResource})
		if err != nil {
			return err
		}
		err = p.notifier.Push(
			FindingNotification{
				TargetID:         source.Target,
				Target:           target,
				IssueID:          issue.ID,
				FindingID:        f.ID,
				CheckID:          source.Instance,
				ChecktypeName:    source.Component,
				CheckTypeOptions: source.Options,
				Tag:              tag,
				Time:             source.Time,
				Vulnerability: vulnerability{
					ID:          issue.ID,
					Summary:     issue.Summary,
					Score:       float32(sf.Score),
					CWEID:       issue.CWEID,
					Description: issue.Description,
				}},
		)
		if err != nil {
			return err
		}
	}
	return nil
}

func parseCheckMssg(m string) (*CheckMessage, error) {
	// Message received from SQS queue is encapsulated in an
	// SNS notification first
	notif := Notification{}
	if err := json.Unmarshal([]byte(m), &notif); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	// Parse notification's inner check data
	check := CheckMessage{}
	if err := json.Unmarshal([]byte(notif.Message), &check); err != nil {
		return nil, ErrInvalidMssgFmt
	}

	return &check, nil
}
