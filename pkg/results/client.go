/*
Copyright 2020 Adevinta
*/

package results

import (
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"

	report "github.com/adevinta/vulcan-report"
	log "github.com/sirupsen/logrus"
)

var (
	// ErrInvalidURL indicates that the specified URL is not valid.
	ErrInvalidURL = errors.New("Invalid URL")
	// ErrInvalidRespStatus indicates that server responded with an HTTP status different than 200.
	ErrInvalidRespStatus = errors.New("Invalid response status from server")
)

const (
	downloadErrTmpl = "Error downloading report: Server response status %d for URL %s"
)

// Client represents a client to download a check results report.
type Client interface {
	Download(reportURL string) (report.Report, error)
}

type reportClient struct {
	logger *log.Logger
}

// NewClient builds and returns a new ReportClient.
func NewClient(logger *log.Logger) (Client, error) {
	return &reportClient{logger}, nil
}

// Download downloads and unmarshals the execution report of a check.
func (c *reportClient) Download(reportURL string) (report.Report, error) {
	if reportURL == "" {
		return report.Report{}, ErrInvalidURL
	}

	resp, err := http.Get(reportURL)
	if err != nil {
		return report.Report{}, err
	}
	defer resp.Body.Close() // nolint: errcheck

	if resp.StatusCode != http.StatusOK {
		errMssg := fmt.Sprintf(downloadErrTmpl, resp.StatusCode, reportURL)
		c.logger.Error(errMssg)
		return report.Report{}, ErrInvalidRespStatus
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return report.Report{}, err
	}

	var r report.Report
	if err := r.UnmarshalJSONTimeAsString(body); err != nil {
		return report.Report{}, err
	}

	return r, nil
}
